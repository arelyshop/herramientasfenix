<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fenix Editor Pro - Sistema de Capas</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;600;700&display=swap');
        
        body {
            font-family: 'Plus Jakarta Sans', sans-serif;
            background-color: #0f172a;
            color: #f8fafc;
            overflow: hidden; /* Evita el scroll global */
        }

        .editor-container {
            display: grid;
            grid-template-columns: 280px 1fr 300px;
            height: 100vh;
        }

        .canvas-area {
            background-image: radial-gradient(#334155 1px, transparent 1px);
            background-size: 20px 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            padding: 2rem;
            overflow: hidden; /* El canvas se ajustar√°, no necesita scroll interno */
        }

        #canvas-wrapper {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            /* Asegura que el contenedor respete el alto del canvas escalado */
            height: 100%; 
            width: 100%;
        }

        canvas {
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            background-color: white;
            cursor: crosshair;
            
            /* AJUSTE DIN√ÅMICO AL ALTO DE PANTALLA */
            max-height: 85vh; /* Se ajusta al 85% del alto de la ventana */
            max-width: 100%;  /* No se sale por los lados */
            height: auto;
            width: auto;
            aspect-ratio: 1 / 1; /* Mantiene la proporci√≥n 1000x1000 */
            object-fit: contain;
        }

        .layer-item.active {
            background-color: #334155;
            border-left: 4px solid #38bdf8;
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: #1e293b; }
        ::-webkit-scrollbar-thumb { background: #475569; border-radius: 10px; }
        ::-webkit-scrollbar-thumb:hover { background: #64748b; }

        .tool-btn.active {
            background-color: #38bdf8;
            color: #0f172a;
        }
    </style>
</head>
<body>

    <div class="editor-container">
        <!-- Barra de Herramientas Izquierda -->
        <aside class="bg-slate-900 border-r border-slate-800 p-4 flex flex-col gap-6">
            <div class="flex items-center gap-3 px-2">
                <div class="w-8 h-8 bg-sky-500 rounded-lg flex items-center justify-center font-bold text-slate-900">F</div>
                <h1 class="text-lg font-bold tracking-tight">Fenix Pro</h1>
            </div>

            <nav class="space-y-2">
                <p class="text-[10px] font-bold text-slate-500 uppercase px-2 mb-2">Herramientas</p>
                <button onclick="setMode('select')" id="btn-select" class="tool-btn active w-full flex items-center gap-3 p-3 rounded-xl transition-all hover:bg-slate-800">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 15l-2 5L9 9l11 4-5 2zm0 0l5 5"></path></svg>
                    <span class="text-sm font-medium">Seleccionar</span>
                </button>
                <button onclick="setMode('brush')" id="btn-brush" class="tool-btn w-full flex items-center gap-3 p-3 rounded-xl transition-all hover:bg-slate-800">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z"></path></svg>
                    <span class="text-sm font-medium">Pincel</span>
                </button>
                <button onclick="setMode('crop')" id="btn-crop" class="tool-btn w-full flex items-center gap-3 p-3 rounded-xl transition-all hover:bg-slate-800">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.121 14.121L19 19m-7-7l7 7m-7-7l-2.828 2.828M11 11L7 7m4 4L7 15m4-4l4-4"></path></svg>
                    <span class="text-sm font-medium">Recortar</span>
                </button>
            </nav>

            <div class="mt-auto space-y-4">
                <label class="block group cursor-pointer">
                    <div class="bg-sky-500 hover:bg-sky-400 text-slate-900 font-bold py-3 rounded-xl text-center text-sm transition-all shadow-lg shadow-sky-500/20">
                        A√±adir Imagen
                    </div>
                    <input type="file" id="fileInput" class="hidden" accept="image/*">
                </label>
                <button onclick="exportImage()" class="w-full border border-slate-700 hover:bg-slate-800 py-3 rounded-xl text-sm font-medium transition-all">
                    Exportar PNG
                </button>
            </div>
        </aside>

        <!-- √Årea Central del Canvas (Mesa de Trabajo) -->
        <main class="canvas-area relative">
            <div id="canvas-wrapper">
                <!-- Resoluci√≥n interna fija de 1000x1000 -->
                <canvas id="mainCanvas" width="1000" height="1000"></canvas>
                <div id="crop-guide" class="absolute border-2 border-dashed border-sky-400 bg-sky-400/10 pointer-events-none hidden"></div>
            </div>
        </main>

        <!-- Panel de Capas y Propiedades -->
        <aside class="bg-slate-900 border-l border-slate-800 flex flex-col">
            <!-- Propiedades -->
            <div class="p-6 border-b border-slate-800">
                <p class="text-[10px] font-bold text-slate-500 uppercase mb-4">Propiedades de Capa</p>
                
                <div id="no-layer-msg" class="text-slate-500 text-xs italic">Selecciona una capa para editar</div>
                
                <div id="layer-props" class="hidden space-y-4">
                    <div>
                        <label class="block text-xs text-slate-400 mb-2">Opacidad</label>
                        <input type="range" id="prop-opacity" min="0" max="100" class="w-full accent-sky-500">
                    </div>
                    <div>
                        <label class="block text-xs text-slate-400 mb-2">Modo de Fusi√≥n</label>
                        <select id="prop-blend" class="w-full bg-slate-800 border border-slate-700 rounded-lg p-2 text-xs outline-none focus:ring-1 focus:ring-sky-500 text-white">
                            <option value="source-over">Normal</option>
                            <option value="multiply">Multiplicar</option>
                            <option value="screen">Trama (Screen)</option>
                            <option value="overlay">Superponer</option>
                            <option value="darken">Oscurecer</option>
                            <option value="lighten">Aclarar</option>
                        </select>
                    </div>
                    <div class="flex gap-2">
                        <button onclick="deleteActiveLayer()" class="flex-1 bg-red-500/10 text-red-500 hover:bg-red-500 hover:text-white p-2 rounded-lg text-xs font-bold transition-all">Eliminar</button>
                        <div class="flex flex-col gap-1">
                            <button onclick="moveLayerUp()" class="bg-slate-800 p-1 px-2 rounded text-[10px]" title="Subir">‚Üë</button>
                            <button onclick="moveLayerDown()" class="bg-slate-800 p-1 px-2 rounded text-[10px]" title="Bajar">‚Üì</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Lista de Capas -->
            <div class="flex-1 p-6 overflow-y-auto">
                <div class="flex items-center justify-between mb-4">
                    <p class="text-[10px] font-bold text-slate-500 uppercase">Capas</p>
                    <button onclick="addNewDrawingLayer()" class="text-sky-500 hover:text-sky-400 text-[10px] font-bold">+ DIBUJO</button>
                </div>
                <div id="layer-list" class="space-y-2">
                    <!-- Las capas se inyectan aqu√≠ -->
                </div>
            </div>
        </aside>
    </div>

    <!-- Feedback Visual -->
    <div id="toast" class="fixed bottom-8 left-1/2 -translate-x-1/2 bg-slate-800 border border-slate-700 px-6 py-3 rounded-full text-sm font-medium shadow-2xl transition-all opacity-0 pointer-events-none z-50">
        Mensaje aqu√≠
    </div>

    <script>
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        const layerListEl = document.getElementById('layer-list');
        const fileInput = document.getElementById('fileInput');
        const cropGuide = document.getElementById('crop-guide');
        
        const CANVAS_WIDTH = 1000;
        const CANVAS_HEIGHT = 1000;

        let layers = [];
        let activeLayerId = null;
        let currentMode = 'select';
        let isMouseDown = false;
        let startX, startY;
        let dragOffset = { x: 0, y: 0 };
        let brushColor = '#ffffff';
        let brushSize = 5;

        function init() {
            render();
            setupEventListeners();
        }

        function createId() { return Math.random().toString(36).substr(2, 9); }

        function addLayer(type, data = null, name = "Capa") {
            const layer = {
                id: createId(),
                type: type,
                name: name,
                visible: true,
                opacity: 100,
                blend: 'source-over',
                x: 150, 
                y: 150,
                width: 0,
                height: 0,
                content: data,
            };

            if (type === 'image') {
                const img = new Image();
                img.onload = () => {
                    const ratio = Math.min(CANVAS_WIDTH * 0.7 / img.width, CANVAS_HEIGHT * 0.7 / img.height);
                    layer.width = img.width * ratio;
                    layer.height = img.height * ratio;
                    layer.content = img;
                    layers.unshift(layer);
                    setActiveLayer(layer.id);
                    render();
                };
                img.src = data;
            } else if (type === 'drawing') {
                const offCanvas = document.createElement('canvas');
                offCanvas.width = CANVAS_WIDTH;
                offCanvas.height = CANVAS_HEIGHT;
                layer.content = offCanvas;
                layer.width = CANVAS_WIDTH;
                layer.height = CANVAS_HEIGHT;
                layer.x = 0;
                layer.y = 0;
                layers.unshift(layer);
                setActiveLayer(layer.id);
                render();
            }
        }

        function setActiveLayer(id) {
            activeLayerId = id;
            updateUI();
            render();
        }

        function updateUI() {
            layerListEl.innerHTML = '';
            layers.forEach(l => {
                const div = document.createElement('div');
                div.className = `layer-item flex items-center gap-3 p-3 rounded-xl cursor-pointer transition-all hover:bg-slate-800/50 ${activeLayerId === l.id ? 'active' : ''}`;
                div.onclick = () => setActiveLayer(l.id);
                
                div.innerHTML = `
                    <div class="w-8 h-8 bg-slate-800 rounded flex items-center justify-center text-[10px]">
                        ${l.type === 'image' ? 'IMG' : 'DRW'}
                    </div>
                    <span class="text-xs font-medium flex-1 truncate">${l.name}</span>
                    <button onclick="event.stopPropagation(); toggleVisibility('${l.id}')" class="text-slate-500 hover:text-white">
                        ${l.visible ? 'üëÅÔ∏è' : 'üï∂Ô∏è'}
                    </button>
                `;
                layerListEl.appendChild(div);
            });

            const propsEl = document.getElementById('layer-props');
            const noLayerEl = document.getElementById('no-layer-msg');
            const activeLayer = layers.find(l => l.id === activeLayerId);

            if (activeLayer) {
                propsEl.classList.remove('hidden');
                noLayerEl.classList.add('hidden');
                document.getElementById('prop-opacity').value = activeLayer.opacity;
                document.getElementById('prop-blend').value = activeLayer.blend;
            } else {
                propsEl.classList.add('hidden');
                noLayerEl.classList.remove('hidden');
            }
        }

        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            [...layers].reverse().forEach(l => {
                if (!l.visible) return;
                
                ctx.save();
                ctx.globalAlpha = l.opacity / 100;
                ctx.globalCompositeOperation = l.blend;

                if (l.type === 'image') {
                    ctx.drawImage(l.content, l.x, l.y, l.width, l.height);
                } else {
                    ctx.drawImage(l.content, 0, 0);
                }

                if (l.id === activeLayerId && currentMode === 'select') {
                    ctx.strokeStyle = '#38bdf8';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(l.x, l.y, l.width, l.height);
                    ctx.fillStyle = '#38bdf8';
                    ctx.fillRect(l.x + l.width - 8, l.y + l.height - 8, 16, 16);
                }
                
                ctx.restore();
            });
        }

        function setupEventListeners() {
            canvas.addEventListener('mousedown', e => {
                isMouseDown = true;
                const pos = getMousePos(e);
                startX = pos.x;
                startY = pos.y;

                const activeLayer = layers.find(l => l.id === activeLayerId);

                if (currentMode === 'select' && activeLayer) {
                    const isResizing = (pos.x >= activeLayer.x + activeLayer.width - 20 && 
                                       pos.x <= activeLayer.x + activeLayer.width + 20 &&
                                       pos.y >= activeLayer.y + activeLayer.height - 20 && 
                                       pos.y <= activeLayer.y + activeLayer.height + 20);
                    
                    if (isResizing) {
                        activeLayer.isResizing = true;
                    } else if (pos.x >= activeLayer.x && pos.x <= activeLayer.x + activeLayer.width &&
                               pos.y >= activeLayer.y && pos.y <= activeLayer.y + activeLayer.height) {
                        activeLayer.isDragging = true;
                        dragOffset.x = pos.x - activeLayer.x;
                        dragOffset.y = pos.y - activeLayer.y;
                    }
                } else if (currentMode === 'crop') {
                    cropGuide.classList.remove('hidden');
                    updateCropGuide(pos.x, pos.y, 0, 0);
                }
            });

            window.addEventListener('mousemove', e => {
                if (!isMouseDown) return;
                const pos = getMousePos(e);
                const activeLayer = layers.find(l => l.id === activeLayerId);

                if (currentMode === 'select' && activeLayer) {
                    if (activeLayer.isResizing) {
                        activeLayer.width = Math.max(10, pos.x - activeLayer.x);
                        activeLayer.height = Math.max(10, pos.y - activeLayer.y);
                    } else if (activeLayer.isDragging) {
                        activeLayer.x = pos.x - dragOffset.x;
                        activeLayer.y = pos.y - dragOffset.y;
                    }
                    render();
                } else if (currentMode === 'brush' && activeLayer && activeLayer.type === 'drawing') {
                    const lCtx = activeLayer.content.getContext('2d');
                    lCtx.lineCap = 'round';
                    lCtx.strokeStyle = brushColor;
                    lCtx.lineWidth = brushSize;
                    lCtx.beginPath();
                    lCtx.moveTo(startX, startY);
                    lCtx.lineTo(pos.x, pos.y);
                    lCtx.stroke();
                    startX = pos.x;
                    startY = pos.y;
                    render();
                } else if (currentMode === 'crop') {
                    const w = pos.x - startX;
                    const h = pos.y - startY;
                    updateCropGuide(startX, startY, w, h);
                }
            });

            window.addEventListener('mouseup', () => {
                isMouseDown = false;
                layers.forEach(l => {
                    l.isDragging = false;
                    l.isResizing = false;
                });

                if (currentMode === 'crop' && !cropGuide.classList.contains('hidden')) {
                    applyCrop();
                }
            });

            document.getElementById('prop-opacity').oninput = (e) => {
                const layer = layers.find(l => l.id === activeLayerId);
                if (layer) { layer.opacity = e.target.value; render(); }
            };

            document.getElementById('prop-blend').onchange = (e) => {
                const layer = layers.find(l => l.id === activeLayerId);
                if (layer) { layer.blend = e.target.value; render(); }
            };

            fileInput.onchange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (ev) => addLayer('image', ev.target.result, file.name);
                    reader.readAsDataURL(file);
                    fileInput.value = ""; // Reset for same file
                }
            };
        }

        // Funci√≥n cr√≠tica: traduce coordenadas visuales escaladas a coordenadas internas 1000x1000
        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            return {
                x: (e.clientX - rect.left) * scaleX,
                y: (e.clientY - rect.top) * scaleY
            };
        }

        function setMode(mode) {
            currentMode = mode;
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
            document.getElementById('btn-' + mode).classList.add('active');
            cropGuide.classList.add('hidden');
            showToast(`Herramienta: ${mode.toUpperCase()}`);
        }

        function updateCropGuide(x, y, w, h) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = rect.width / canvas.width;
            const scaleY = rect.height / canvas.height;
            
            cropGuide.style.left = (x * scaleX) + 'px';
            cropGuide.style.top = (y * scaleY) + 'px';
            cropGuide.style.width = (Math.abs(w) * scaleX) + 'px';
            cropGuide.style.height = (Math.abs(h) * scaleY) + 'px';
        }

        function applyCrop() {
            const rect = cropGuide.getBoundingClientRect();
            const canvasRect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / canvasRect.width;
            const scaleY = canvas.height / canvasRect.height;

            const cropX = (rect.left - canvasRect.left) * scaleX;
            const cropY = (rect.top - canvasRect.top) * scaleY;
            const cropW = rect.width * scaleX;
            const cropH = rect.height * scaleY;

            if (cropW < 10 || cropH < 10) {
                cropGuide.classList.add('hidden');
                return;
            }

            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = cropW;
            tempCanvas.height = cropH;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(canvas, cropX, cropY, cropW, cropH, 0, 0, cropW, cropH);

            if (confirm("¬øDeseas aplicar el recorte? Esto combinar√° las capas en una sola de 1000x1000.")) {
                const croppedData = tempCanvas.toDataURL();
                layers = [];
                addLayer('image', croppedData, 'Resultado Recorte');
                showToast("Recorte finalizado.");
            }

            cropGuide.classList.add('hidden');
            setMode('select');
        }

        function toggleVisibility(id) {
            const layer = layers.find(l => l.id === id);
            if (layer) { layer.visible = !layer.visible; render(); updateUI(); }
        }

        function deleteActiveLayer() {
            layers = layers.filter(l => l.id !== activeLayerId);
            activeLayerId = layers.length > 0 ? layers[0].id : null;
            render();
            updateUI();
        }

        function moveLayerUp() {
            const idx = layers.findIndex(l => l.id === activeLayerId);
            if (idx > 0) {
                [layers[idx], layers[idx-1]] = [layers[idx-1], layers[idx]];
                render();
                updateUI();
            }
        }

        function moveLayerDown() {
            const idx = layers.findIndex(l => l.id === activeLayerId);
            if (idx !== -1 && idx < layers.length - 1) {
                [layers[idx], layers[idx+1]] = [layers[idx+1], layers[idx]];
                render();
                updateUI();
            }
        }

        function addNewDrawingLayer() {
            addLayer('drawing', null, 'Capa de Dibujo ' + (layers.length + 1));
        }

        function showToast(msg) {
            const toast = document.getElementById('toast');
            toast.textContent = msg;
            toast.classList.add('opacity-100');
            setTimeout(() => toast.classList.remove('opacity-100'), 2000);
        }

        function exportImage() {
            setActiveLayer(null);
            setTimeout(() => {
                const link = document.createElement('a');
                link.download = 'fenix-master-' + Date.now() + '.png';
                link.href = canvas.toDataURL('image/png');
                link.click();
                showToast("Archivo exportado a 1000x1000px");
            }, 100);
        }

        init();
    </script>
</body>
</html>
