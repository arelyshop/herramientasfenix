<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Editor de Imágenes - Plantilla Corporativa</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
            user-select: none;
        }

        .canvas-container {
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1), 0 8px 10px -6px rgba(0, 0, 0, 0.1);
            max-width: 100%;
            overflow: hidden;
        }

        canvas {
            max-width: 100%;
            height: auto;
            display: block;
            background-color: white;
        }

        .custom-file-upload {
            border: 2px dashed #cbd5e1;
            transition: all 0.3s ease;
        }

        .custom-file-upload:hover {
            border-color: #2c4c82;
            background-color: #f8fafc;
        }

        input[type=range] {
            accent-color: #2c4c82;
        }

        .mode-btn.active {
            background-color: #2c4c82;
            color: white;
            border-color: #2c4c82;
        }

        #textModal {
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(2px);
        }
    </style>
</head>
<body class="min-h-screen py-8 px-4">
    <div class="max-w-6xl mx-auto">
        <header class="text-center mb-8">
            <h1 class="text-3xl font-bold text-slate-800">Editor de Plantilla</h1>
            <p class="text-slate-500 mt-2">Personaliza tu producto con logos, ajustes, medidas y retoques.</p>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-4 gap-8">
            <!-- Panel de Control -->
            <div class="lg:col-span-1 space-y-5 bg-white p-5 rounded-2xl shadow-sm border border-slate-100 h-fit">
                
                <!-- Herramientas Principales -->
                <div class="space-y-2">
                    <label class="block text-sm font-semibold text-slate-700">Herramientas</label>
                    <div class="grid grid-cols-3 gap-2">
                        <button id="modeMove" title="Mover Imagen" class="mode-btn active flex flex-col items-center justify-center p-2 border rounded-xl text-[10px] font-medium transition-all">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mb-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 11l5-5m0 0l5 5m-5-5v12" />
                            </svg>
                            Mover
                        </button>
                        <button id="modeMeasure" title="Trazar Medida" class="mode-btn flex flex-col items-center justify-center p-2 border rounded-xl text-[10px] font-medium transition-all">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mb-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.121 14.121L19 19m-7-7l7 7m-7-7l-2.828 2.828M11 11L7 7m4 4L7 15m4-4l4-4" />
                            </svg>
                            Medida
                        </button>
                        <button id="modeBrush" title="Pincel/Borrador" class="mode-btn flex flex-col items-center justify-center p-2 border rounded-xl text-[10px] font-medium transition-all">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mb-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z" />
                            </svg>
                            Pincel
                        </button>
                    </div>
                </div>

                <!-- Configuración Pincel -->
                <div id="brushSettings" class="hidden space-y-3 p-3 bg-slate-50 rounded-xl border border-slate-100 animate-in slide-in-from-top duration-200">
                    <div>
                        <label class="flex justify-between text-[11px] font-semibold text-slate-600 mb-1">
                            <span>Grosor del Pincel</span>
                            <span id="brushSizeVal">20px</span>
                        </label>
                        <input type="range" id="brushSize" min="5" max="100" value="20" class="w-full h-1.5 bg-slate-200 rounded-lg appearance-none cursor-pointer">
                    </div>
                    <button id="clearBrush" class="w-full py-1.5 text-[10px] bg-white border border-slate-200 rounded-lg text-slate-600 hover:bg-slate-100 transition-colors">
                        Limpiar todos los trazos
                    </button>
                </div>

                <!-- Configuración Medidas -->
                <div id="measureSettings" class="hidden space-y-2">
                    <p class="text-[10px] text-slate-400 italic mb-2 leading-tight">
                        • Mantén presionada la 'X' para mover la medida.<br>
                        • Un clic corto en la 'X' para eliminarla.<br>
                        • Mantén <b>Shift</b> al trazar para líneas rectas.
                    </p>
                    <button id="clearMeasures" class="w-full py-2 bg-red-50 text-red-600 rounded-lg text-xs font-bold border border-red-100 hover:bg-red-100 transition-colors">
                        Borrar todas las medidas
                    </button>
                </div>

                <hr class="border-slate-100">

                <div>
                    <label class="block text-sm font-semibold text-slate-700 mb-2">1. Imagen del Producto</label>
                    <label class="custom-file-upload flex flex-col items-center justify-center p-3 rounded-xl cursor-pointer">
                        <span class="text-xs text-slate-500">Subir producto</span>
                        <input type="file" id="imageInput" class="hidden" accept="image/*">
                    </label>
                </div>

                <div>
                    <label class="flex justify-between text-sm font-semibold text-slate-700 mb-2">
                        <span>2. Tamaño Imagen</span>
                        <span id="zoomValue" class="text-xs text-slate-400">100%</span>
                    </label>
                    <input type="range" id="zoomInput" min="10" max="300" value="100" class="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer">
                </div>

                <div>
                    <label class="block text-sm font-semibold text-slate-700 mb-2">3. Logo Corporativo</label>
                    <label class="custom-file-upload flex flex-col items-center justify-center p-3 rounded-xl cursor-pointer">
                        <span class="text-xs text-slate-500">Actualizar logofenix.png</span>
                        <input type="file" id="logoInput" class="hidden" accept="image/*">
                    </label>
                    <p class="text-[9px] text-slate-400 mt-1">Se carga automáticamente desde images/logofenix.png</p>
                </div>

                <div class="pt-2">
                    <button id="downloadBtn" class="w-full bg-[#2c4c82] hover:bg-[#1e355c] text-white font-bold py-3 px-6 rounded-xl transition duration-200 flex items-center justify-center space-x-2 shadow-lg shadow-blue-900/20">
                        <span>Descargar Imagen</span>
                    </button>
                    <p id="statusMsg" class="mt-2 text-center text-[10px] font-bold hidden"></p>
                </div>
            </div>

            <!-- Previsualización -->
            <div class="lg:col-span-3 flex flex-col items-center">
                <div class="w-full bg-slate-300 rounded-2xl p-4 md:p-8 flex items-center justify-center min-h-[600px]">
                    <div id="canvasWrapper" class="canvas-container bg-white rounded shadow-2xl relative">
                        <canvas id="editorCanvas" width="1000" height="1000"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal para ingresar texto de medida -->
    <div id="textModal" class="fixed inset-0 z-50 flex items-center justify-center hidden">
        <div class="bg-white p-6 rounded-2xl shadow-2xl w-80 transform transition-all border border-slate-200">
            <h3 class="text-sm font-bold text-slate-700 mb-3 uppercase tracking-wider text-center">Ingresa la medida</h3>
            <input type="text" id="modalInput" placeholder="Ej: 50 cm" class="w-full px-4 py-3 border border-slate-200 rounded-xl text-lg text-center focus:outline-none focus:ring-2 focus:ring-[#2c4c82] mb-4">
            <div class="flex space-x-2">
                <button id="cancelText" class="flex-1 px-4 py-2 bg-slate-100 text-slate-600 rounded-xl font-bold text-sm">Cancelar</button>
                <button id="saveText" class="flex-1 px-4 py-2 bg-[#2c4c82] text-white rounded-xl font-bold text-sm">Guardar</button>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('editorCanvas');
        const ctx = canvas.getContext('2d');
        const imageInput = document.getElementById('imageInput');
        const logoInput = document.getElementById('logoInput');
        const zoomInput = document.getElementById('zoomInput');
        const zoomValueLabel = document.getElementById('zoomValue');
        const downloadBtn = document.getElementById('downloadBtn');
        const statusMsg = document.getElementById('statusMsg');
        
        const modeMoveBtn = document.getElementById('modeMove');
        const modeMeasureBtn = document.getElementById('modeMeasure');
        const modeBrushBtn = document.getElementById('modeBrush');
        
        const brushSettings = document.getElementById('brushSettings');
        const brushSizeInput = document.getElementById('brushSize');
        const brushSizeValLabel = document.getElementById('brushSizeVal');
        const clearBrushBtn = document.getElementById('clearBrush');

        const measureSettings = document.getElementById('measureSettings');
        const clearMeasuresBtn = document.getElementById('clearMeasures');

        const textModal = document.getElementById('textModal');
        const modalInput = document.getElementById('modalInput');
        const saveTextBtn = document.getElementById('saveText');
        const cancelTextBtn = document.getElementById('cancelText');

        const CONFIG = {
            width: 1000,
            height: 1000,
            barHeight: 45,
            barColor: '#f2cd42',
            textColor: '#2c4c82',
            text: "Revise el producto al recibirlo. Cambios por fallas de fábrica dentro de 48 h.",
            font: "bold 22px Inter, sans-serif",
            measureFont: "bold 24px Inter, sans-serif",
            measureColor: "#000000",
            logoWidth: 177,
            logoHeight: 80,
            logoMarginLeft: 35,
            logoMarginBottom: 63,
            deleteBtnRadius: 14,
            logoPath: 'images/logofenix.png'
        };

        let mainImage = null;
        let logoImage = null;
        let currentMode = 'move';
        let measures = []; 
        let activeMeasure = null;
        let pendingMeasure = null;
        let strokes = [];
        let activeStroke = null;

        // Arrastre de medidas existentes a través de la X
        let draggingMeasureIdx = -1;
        let mDragOffset = { x: 0, y: 0 };
        let hasMovedDraggedMeasure = false;

        let imgState = {
            x: 0, y: 0, baseWidth: 0, baseHeight: 0, width: 0, height: 0, scale: 1.0,
            isDragging: false, dragStartX: 0, dragStartY: 0
        };

        function loadDefaultLogo() {
            const img = new Image();
            img.crossOrigin = "anonymous";
            img.onload = () => {
                logoImage = img;
                draw();
            };
            img.onerror = () => {
                console.warn("No se pudo cargar el logo desde " + CONFIG.logoPath);
            };
            img.src = CONFIG.logoPath;
        }

        function draw(isExporting = false) {
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, CONFIG.width, CONFIG.height);
            
            if (mainImage) {
                ctx.drawImage(mainImage, imgState.x, imgState.y, imgState.width, imgState.height);
            } else if (!isExporting) {
                ctx.fillStyle = '#f1f5f9';
                ctx.font = "20px Inter";
                ctx.textAlign = "center";
                ctx.fillStyle = "#94a3b8";
                ctx.fillText("Sube una imagen para comenzar", CONFIG.width / 2, CONFIG.height / 2);
            }

            drawBrushStrokes();

            measures.forEach((m, index) => drawMeasureLine(m, index, isExporting));
            if (activeMeasure) drawMeasureLine(activeMeasure, -1, isExporting);

            if (logoImage) {
                const lx = CONFIG.logoMarginLeft;
                const ly = CONFIG.height - CONFIG.logoMarginBottom - CONFIG.logoHeight;
                ctx.drawImage(logoImage, lx, ly, CONFIG.logoWidth, CONFIG.logoHeight);
            }

            ctx.fillStyle = CONFIG.barColor;
            ctx.fillRect(0, CONFIG.height - CONFIG.barHeight, CONFIG.width, CONFIG.barHeight);
            ctx.fillStyle = CONFIG.textColor;
            ctx.font = CONFIG.font;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(CONFIG.text, CONFIG.width / 2, CONFIG.height - (CONFIG.barHeight / 2));
        }

        function drawBrushStrokes() {
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.strokeStyle = '#ffffff';
            const allStrokes = [...strokes];
            if (activeStroke) allStrokes.push(activeStroke);
            allStrokes.forEach(stroke => {
                if (stroke.points.length < 2) return;
                ctx.lineWidth = stroke.size;
                ctx.beginPath();
                ctx.moveTo(stroke.points[0].x, stroke.points[0].y);
                for (let i = 1; i < stroke.points.length; i++) {
                    ctx.lineTo(stroke.points[i].x, stroke.points[i].y);
                }
                ctx.stroke();
            });
        }

        function drawMeasureLine(m, index, isExporting) {
            const { x1, y1, x2, y2, text } = m;
            const dist = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
            const angle = Math.atan2(y2 - y1, x2 - x1);
            
            ctx.strokeStyle = CONFIG.measureColor;
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';

            ctx.save();
            ctx.translate(x1, y1);
            ctx.rotate(angle);

            let gap = 0;
            let textWidth = 0;
            if (text) {
                ctx.font = CONFIG.measureFont;
                textWidth = ctx.measureText(text).width;
                gap = textWidth + 40; // Padding incrementado para asegurar transparencia detrás del texto
            }

            if (text && dist > gap) {
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(dist / 2 - gap / 2, 0);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(dist / 2 + gap / 2, 0);
                ctx.lineTo(dist, 0);
                ctx.stroke();
            } else {
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(dist, 0);
                ctx.stroke();
            }

            const barLen = 15;
            function drawBarLocal(x) {
                ctx.beginPath();
                ctx.moveTo(x, -barLen);
                ctx.lineTo(x, barLen);
                ctx.stroke();
            }
            drawBarLocal(0);
            drawBarLocal(dist);

            if (text) {
                ctx.save();
                ctx.translate(dist / 2, 0);
                if (angle > Math.PI / 2 || angle < -Math.PI / 2) {
                    ctx.rotate(Math.PI);
                }
                ctx.fillStyle = CONFIG.measureColor;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(text, 0, 0);
                ctx.restore();
            }

            ctx.restore();

            if (index !== -1 && !isExporting) {
                const btnX = x2;
                const btnY = y2 - 25; 
                m.deleteBtn = { x: btnX, y: btnY };

                ctx.save();
                ctx.shadowColor = "rgba(0,0,0,0.3)";
                ctx.shadowBlur = 4;
                ctx.fillStyle = draggingMeasureIdx === index ? '#1e355c' : '#ef4444';
                ctx.beginPath();
                ctx.arc(btnX, btnY, CONFIG.deleteBtnRadius, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;

                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                const s = 5;
                ctx.moveTo(btnX - s, btnY - s);
                ctx.lineTo(btnX + s, btnY + s);
                ctx.moveTo(btnX + s, btnY - s);
                ctx.lineTo(btnX - s, btnY + s);
                ctx.stroke();
                ctx.restore();
            } else if (isExporting) {
                m.deleteBtn = null;
            }
        }

        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const clientX = (e.touches ? e.touches[0].clientX : e.clientX);
            const clientY = (e.touches ? e.touches[0].clientY : e.clientY);
            return { x: (clientX - rect.left) * scaleX, y: (clientY - rect.top) * scaleY };
        }

        canvas.addEventListener('mousedown', (e) => {
            if (!textModal.classList.contains('hidden')) return;
            const pos = getMousePos(e);

            // Verificar si clicamos en una X de medida
            for (let i = measures.length - 1; i >= 0; i--) {
                const m = measures[i];
                if (m.deleteBtn) {
                    const dist = Math.sqrt(Math.pow(pos.x - m.deleteBtn.x, 2) + Math.pow(pos.y - m.deleteBtn.y, 2));
                    if (dist <= CONFIG.deleteBtnRadius + 5) {
                        draggingMeasureIdx = i;
                        mDragOffset.x = pos.x;
                        mDragOffset.y = pos.y;
                        hasMovedDraggedMeasure = false;
                        draw();
                        return;
                    }
                }
            }
            
            if (currentMode === 'move') {
                if (mainImage && pos.x >= imgState.x && pos.x <= imgState.x + imgState.width &&
                    pos.y >= imgState.y && pos.y <= imgState.y + imgState.height) {
                    imgState.isDragging = true;
                    imgState.dragStartX = pos.x - imgState.x;
                    imgState.dragStartY = pos.y - imgState.y;
                }
            } else if (currentMode === 'measure') {
                activeMeasure = { x1: pos.x, y1: pos.y, x2: pos.x, y2: pos.y, text: "" };
            } else if (currentMode === 'brush') {
                activeStroke = { size: parseInt(brushSizeInput.value), points: [pos] };
            }
        });

        window.addEventListener('mousemove', (e) => {
            const pos = getMousePos(e);

            // Arrastre de medida completa
            if (draggingMeasureIdx !== -1) {
                const dx = pos.x - mDragOffset.x;
                const dy = pos.y - mDragOffset.y;
                if (Math.abs(dx) > 2 || Math.abs(dy) > 2) hasMovedDraggedMeasure = true;

                const m = measures[draggingMeasureIdx];
                m.x1 += dx;
                m.x2 += dx;
                m.y1 += dy;
                m.y2 += dy;
                
                mDragOffset.x = pos.x;
                mDragOffset.y = pos.y;
                draw();
                return;
            }

            if (imgState.isDragging) {
                imgState.x = pos.x - imgState.dragStartX;
                imgState.y = pos.y - imgState.dragStartY;
                draw();
            } else if (activeMeasure) {
                if (e.shiftKey) {
                    const dx = pos.x - activeMeasure.x1;
                    const dy = pos.y - activeMeasure.y1;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const angle = Math.atan2(dy, dx);
                    const snapAngle = Math.round(angle / (Math.PI / 4)) * (Math.PI / 4);
                    activeMeasure.x2 = activeMeasure.x1 + Math.cos(snapAngle) * dist;
                    activeMeasure.y2 = activeMeasure.y1 + Math.sin(snapAngle) * dist;
                } else {
                    activeMeasure.x2 = pos.x;
                    activeMeasure.y2 = pos.y;
                }
                draw();
            } else if (activeStroke) {
                activeStroke.points.push(pos);
                draw();
            }
        });

        window.addEventListener('mouseup', () => {
            // Finalizar arrastre de medida
            if (draggingMeasureIdx !== -1) {
                if (!hasMovedDraggedMeasure) {
                    // Si no se movió, era un clic corto -> eliminar
                    measures.splice(draggingMeasureIdx, 1);
                }
                draggingMeasureIdx = -1;
                draw();
                return;
            }

            if (imgState.isDragging) {
                imgState.isDragging = false;
            } else if (activeMeasure) {
                const dist = Math.sqrt(Math.pow(activeMeasure.x2 - activeMeasure.x1, 2) + Math.pow(activeMeasure.y2 - activeMeasure.y1, 2));
                if (dist > 10) {
                    pendingMeasure = {...activeMeasure};
                    openTextModal();
                }
                activeMeasure = null;
                draw();
            } else if (activeStroke) {
                strokes.push(activeStroke);
                activeStroke = null;
                draw();
            }
        });

        function updateBrushCursor() {
            if (currentMode !== 'brush') return;
            const size = parseInt(brushSizeInput.value);
            const rect = canvas.getBoundingClientRect();
            const scale = rect.width / CONFIG.width;
            const displaySize = Math.max(Math.floor(size * scale), 4);
            const r = displaySize / 2;
            const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${displaySize}" height="${displaySize}"><circle cx="${r}" cy="${r}" r="${r-1}" fill="none" stroke="rgba(0,0,0,0.5)" stroke-width="1"/><circle cx="${r}" cy="${r}" r="${r-2}" fill="none" stroke="rgba(255,255,255,0.8)" stroke-width="1"/></svg>`;
            canvas.style.cursor = `url("data:image/svg+xml;base64,${btoa(svg)}") ${r} ${r}, auto`;
        }

        brushSizeInput.oninput = (e) => {
            brushSizeValLabel.textContent = e.target.value + "px";
            updateBrushCursor();
        };

        function openTextModal() {
            textModal.classList.remove('hidden');
            modalInput.value = "";
            modalInput.focus();
        }

        saveTextBtn.onclick = () => {
            if (pendingMeasure) {
                pendingMeasure.text = modalInput.value;
                measures.push(pendingMeasure);
                draw();
            }
            textModal.classList.add('hidden');
            pendingMeasure = null;
        };

        cancelTextBtn.onclick = () => {
            textModal.classList.add('hidden');
            pendingMeasure = null;
            draw();
        };

        modalInput.onkeydown = (e) => {
            if (e.key === 'Enter') saveTextBtn.onclick();
            if (e.key === 'Escape') cancelTextBtn.onclick();
        };

        function setMode(mode) {
            currentMode = mode;
            [modeMoveBtn, modeMeasureBtn, modeBrushBtn].forEach(btn => btn.classList.remove('active'));
            measureSettings.classList.add('hidden');
            brushSettings.classList.add('hidden');
            if (mode === 'move') {
                modeMoveBtn.classList.add('active');
                canvas.style.cursor = 'move';
            } else if (mode === 'measure') {
                modeMeasureBtn.classList.add('active');
                measureSettings.classList.remove('hidden');
                canvas.style.cursor = 'crosshair';
            } else if (mode === 'brush') {
                modeBrushBtn.classList.add('active');
                brushSettings.classList.remove('hidden');
                updateBrushCursor();
            }
        }

        modeMoveBtn.onclick = () => setMode('move');
        modeMeasureBtn.onclick = () => setMode('measure');
        modeBrushBtn.onclick = () => setMode('brush');
        clearBrushBtn.onclick = () => { strokes = []; draw(); };
        clearMeasuresBtn.onclick = () => { measures = []; draw(); };

        zoomInput.addEventListener('input', (e) => {
            if (!mainImage) return;
            const newScale = e.target.value / 100;
            zoomValueLabel.textContent = `${e.target.value}%`;
            const centerX = imgState.x + imgState.width / 2;
            const centerY = imgState.y + imgState.height / 2;
            imgState.scale = newScale;
            imgState.width = imgState.baseWidth * imgState.scale;
            imgState.height = imgState.baseHeight * imgState.scale;
            imgState.x = centerX - imgState.width / 2;
            imgState.y = centerY - imgState.height / 2;
            draw();
        });

        imageInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    mainImage = img;
                    const ratio = Math.max(CONFIG.width / img.width, CONFIG.height / img.height);
                    imgState.baseWidth = img.width * ratio;
                    imgState.baseHeight = img.height * ratio;
                    imgState.width = imgState.baseWidth;
                    imgState.height = imgState.baseHeight;
                    imgState.x = (CONFIG.width - imgState.width) / 2;
                    imgState.y = (CONFIG.height - imgState.height) / 2;
                    draw();
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        });

        logoInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => { logoImage = img; draw(); };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        });

        downloadBtn.onclick = () => {
            if (!mainImage) return;
            draw(true);
            const link = document.createElement('a');
            link.download = `producto-fenix-${Date.now()}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
            draw(false);
        };

        window.onload = () => {
            draw();
            loadDefaultLogo();
        };
    </script>
</body>
</html>
